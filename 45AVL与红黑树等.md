关于红黑树，其实知道下面这个网址的内容就可以  
https://blog.csdn.net/v_JULY_v/article/details/6105630  
  
【红黑树有哪些性质？】   
一般的，红黑树，满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：  
1）每个结点要么是红的，要么是黑的。  
2）根结点是黑的。  
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  
  
【红黑树的各种操作的时间复杂度是多少？】  
能保证在最坏情况下，基本的动态几何操作的时间均为O（lgn）  
  
【红黑树相比于BST和AVL树有什么优点？】  
红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。  
红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。  
当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。  
  
相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。  
在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。  
  
红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，  
但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.  
如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的  
  
如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB  

这里引用一下知乎上的回答：  
Answer 1：  
1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；  
但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，  
因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。  
2. 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，  
因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。  
自然，由于AVL高度平衡，因此AVL的search效率更高。  
3. map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。  
链接：http://www.zhihu.com/question/20545708/answer/58717264
  
Answer 2  这个总结比较好：  
红黑树的查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，  
但是，红黑树在插入和删除上完爆avl树，avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，  
相较于avl树为了维持平衡的开销要小得多  
链接：http://www.zhihu.com/question/43744788/answer/98258881  
  
Answer 3 ：  
功能、性能、空间开销的折中结果。  
AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。  
红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。  
基本上主要的几种平衡树看来，红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强，在诸如STL的场景中需要稳定表现。  
链接：http://www.zhihu.com/question/20545708/answer/44370878
  
【红黑树相对于哈希表，在选择使用的时候有什么依据？】
权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性。  
总体来说，hash查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;
而map的查找速度是log(n)级别。并不一定常数就比log(n) 小，hash还有hash函数的耗时   
如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash。  
但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，  
特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。  
  
红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。  
如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。  
  
在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。  
Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。  
  
红黑树通过扩展节点域可以在不改变时间复杂度的情况下得到结点的秩。  
