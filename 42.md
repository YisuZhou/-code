动态规划  
从右往左，看当前位置右边的那些所有最长递减子序列里的最大值有没有比当前位置小的  
d[i]=max{d[k]| i<k<=n 且a[i]>a[k]} +1  
边界i == n 的时候是1  
  
无优化算法，O(n^2)  
https://blog.csdn.net/stormbjm/article/details/8919484  
优化算法，优化的是找剩下来的里面的那个过程  
对于序列A中的每个元素A[i]，我们都可以快速找到“小于A[i]的所有元素中F的值最大的那个”，二分，O(nlogn)  
https://blog.csdn.net/weixin_41162823/article/details/81901569  
  
下面实现一个无优化的  
def  LDS(array):
    n = len(array)
    d = [1]*n  #
    p = [-1]*n  #
    # 
    for i in range(n-1,-1,-1):
        if i == n-1:
            d[i]=1
        else:
            #
            mmax, mindex = search(array,d,i+1,len(array))
            d[i] = mmax+1
            p[i] = mindex
    #
    max_len = max(d)
    print(d)
    print(p)
    #
    max_start_list = []
    for j in range(len(d)):
        if d[j] == max_len:
            max_start_list.append(j)
    ans_all = []
    for max_start in max_start_list:
        ans = [array[max_start]]
        i_next = max_start
        while p[i_next] != -1 :
            ans.append(array[p[i_next]])
            i_next = p[i_next]
        if i_next != max_start:
            ans.append(array[i_next])
        ans_all.append(ans)
    return ans_all

def search(array,d,start,end):
    mmax = 0
    mindex = -1
    for i in range(start,end):
        if array[i] < array[start-1]:
            if mmax < d[i]:
                mmax = d[i]
                mindex = i
    return mmax,mindex

if __name__ == '__main__':
    l = [9,8, 2, 1, 7, 5, 3, 4, 3, 2, 1]
    ans = LDS(l)
    print(ans)
